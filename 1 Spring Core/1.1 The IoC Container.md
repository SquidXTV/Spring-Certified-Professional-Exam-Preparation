# [The IoC container](https://docs.spring.io/spring-framework/reference/core/beans/introduction.html)

This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle.
Dependency injection (DI) is a specialized form of IoC, whereby objects define their dependencies
(that is, the other objects they work with) only through constructor arguments, arguments to a factory method,
or properties that are set on the object instance after it is constructed or returned from a factory method.
The IoC container then injects those dependencies when it creates the bean. This process is fundamentally the
inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location
of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.

The `org.springframework.beans` and `org.springframework.context` packages are the basis for Spring Framework’s IoC
container. The `BeanFactory` interface provides an advanced configuration mechanism capable of managing any type of object.
`ApplicationContext` is a sub-interface of `BeanFactory`. It adds:
- Easier integration with Spring's AOP features
- Message resource handling, supporting internationalization
- Event publication
- Application-layer specific contexts such as the `WebApplicationContext` for use in web applications.

In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext
adds more enterprise-specific functionality.

In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container
are called beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container.
Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are
reflected in the configuration metadata used by a container.

## [Container Overview](https://docs.spring.io/spring-framework/reference/core/beans/basics.html)

The `org.springframework.context.ApplicationContext` interface represents the Spring IoC container and is responsible
for instantiating, configuring, and assembling the beans. The container gets its instructions on the components to
instantiate, configure, and assemble by reading configuration metadata. The configuration metadata can be represented
as annotated component classes, configuration classes with factory methods, or external XML files or Groovy scripts.
With either format, you may compose your application and the rich interdependencies between those components.

Several implementations of the `ApplicationContext` interface are part of core Spring. In stand-alone applications,
it is common to create an instance of `AnnotationConfigApplicationContext` or `ClassPathXmlApplicationContext`.
In a Spring Boot scenario, the application context is implicitly bootstrapped for you based on common setup conventions.


### [Configuration Metadata](https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-metadata)

The Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an
application developer, tell the Spring container to instantiate, configure, and assemble the components in your application.

The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written.
These days, many developers choose Java-based configuration for their Spring applications:
- Annotation-based configuration: define beans using annotations directly on the beans class
- Java-based configuration: define beans external to your application by using `@Configuration` that define bean methods

### [XML as an External Configuration DSL](https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-xml)

XML-based configuration metadata configures these beans as `<bean/>` elements inside a top-level `<beans/>` element.
The following example shows the basic structure of XML-based configuration metadata:

```xml
<beans ...>
    <bean id="..." class="...">  
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->
</beans>
```

1. The `id` attribute is a string that identifies the individual bean definition.
2. The `class` attribute defines the type of the bean and uses the fully qualified class name.

#### [Composing XML-based Configuration Metadata](https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-xml-import)

It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file
represents a logical layer or module in your architecture.

```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

#### [The Groovy Bean Definition DSL](https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-groovy)

As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring’s
Groovy Bean Definition DSL, as known from the Grails framework. Typically, such configuration live in a `.groovy`
file with the structure shown in the following example:

```groovy
beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    
    myService(MyService) {
        nestedBean = { AnotherBean bean ->
            dataSource = dataSource
        }
    }
}
```

This configuration style is largely equivalent to XML bean definitions and even supports Spring’s XML configuration
namespaces. It also allows for importing XML bean definition files through an `importBeans` directive.


### [Using the Container](https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-client)

The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of different beans
and their dependencies. By using the method `T getBean(String name, Class<T> requiredType)`, you can retrieve instances
of your beans.

```java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);
```

The most flexible variant is `GenericApplicationContext` in combination with reader delegates — for example, with
`XmlBeanDefinitionReader` for XML files, as the following example shows:

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

You can mix and match such reader delegates on the same ApplicationContext, reading bean definitions from diverse
configuration sources.

## [Bean Overview](https://docs.spring.io/spring-framework/reference/core/beans/definition.html)

A Spring IoC container manages one or more beans. These beans are created with configuration metadata that you supply
to the container.

Within the container itself, these bean definitions are represented as `BeanDefinition` objects, which contain
(among other information) the following metadata:
- A package-qualified class name
- Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, ...)
- References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.
- Other configuration settings to set in the newly created object

### [Naming Beans](https://docs.spring.io/spring-framework/reference/core/beans/definition.html#beans-beanname)

Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean.
A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.

> The convention is to use the standard Java convention for instance field names when naming beans.
That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names
include accountManager, accountService, userDao, loginController, and so forth.

### [Instantiating Beans](https://docs.spring.io/spring-framework/reference/core/beans/definition.html#beans-factory-class)

A bean definition is essentially a recipe for creating one or more objects. The container looks at the recipe for a named
bean when asked and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual
object.

If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the
`class` attribute of the `<bean/>` element.

## [Dependency Injection](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html)

Dependency injection (DI) is a process whereby objects define their dependencies and the container then injects those
dependencies when it creates the bean. Code is cleaner with the DI principle, and decoupling is more effective when
objects are provided with their dependencies. As a result, your classes become easier to test, particularly when the
dependencies are on interfaces or abstract base classes, which allow for stub/mock implementationsto be used in unit tests.

### [Constructor-based Dependency Injection](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html#beans-constructor-injection)

Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private final MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    //...
}
```

#### [Constructor Argument Resolution](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html#beans-factory-ctor-arguments-resolution)

Constructor argument resolution matching occurs by using the argument’s type. If no potential ambiguity exists in the
constructor arguments of a bean definition, the order in which the constructor arguments are defined in a bean definition
is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated.
Consider the following class:

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

Assuming that the `ThingTwo` and `ThingThree` classes are not related by inheritance, no potential ambiguity exists.
Thus, the following configuration works fine, and you do not need to specify the constructor argument indexes or
types explicitly in the `<constructor-arg/>` element.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

#### Constructor argument type matching

In the following example, the container can use type matching with simple types if you explicitly specify the type
of the constructor argument via the `type` attribute:

When a simple type is used Spring cannot determine the type of the value and so cannot match by type without help.

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private final int years;

    // The Answer to Life, the Universe, and Everything
    private final String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

The container can use type matching with simple types if you explicitly specify the type of the constructor argument
via the `type` attribute:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

#### Constructor argument index

You can use the `index` attribute to specify explicitly the index of constructor arguments, as the following example shows:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor
has two arguments of the same type.

Note: The index is 0-based.

#### Constructor argument name

You can also use the constructor parameter name for value disambiguation, as the following example shows:

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

Keep in mind that, to make this work out of the box, your code must be compiled with the `-parameters` flag enabled
so that Spring can look up the parameter name from the constructor. If you cannot or do not want to compile your code
with the `-parameters` flag, you can use the `@ConstructorProperties` JDK annotation to explicitly name your constructor
arguments. The sample class would then have to look as follows:

```java
package examples;

public class ExampleBean {

    // ...

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

### [Setter-based Dependency Injection](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html#beans-setter-injection)

Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument
constructor or a no-argument `static` factory method to instantiate your bean.

The following example shows a class that can only be dependency-injected by using pure setter injection.
This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces,
base classes, or annotations.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

The `ApplicationContext` supports constructor-based and setter-based DI for the beans it manages.
It also supports setter-based DI after some dependencies have already been injected through the constructor approach

### [Dependency Resolution Process](https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html#beans-dependency-resolution)

The container performs bean dependency resolution as follows:
- The `ApplicationContext` is created and initalized with configuration metadate